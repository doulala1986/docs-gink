## 代码


https://github.com/wangzheng0822/algo

## 数据结构与算法的区别

- 数据结构是指一组数据的存储结构
- 算法是指操作数据的一组方法
- 
## 大 O 复杂度表示法

所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。

>时间复杂度 T（n）= O(f(n)) 
> F(n)=代码行执行次数总和 n为数据规模
> O代表`成正比`,代码执行时间随数据规模增长的变化趋势，


## 如何计算时间复杂度

1. 只关注循环执行次数最多的一点代码
2. 加法法则，总复杂度等于量级最大的那段代码的复杂度。
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积


![](https://static001.geekbang.org/resource/image/37/0a/3723793cc5c810e9d5b06bc95325bf0a.jpg)

## 什么是非多项式量级

上图中O(2^n) 和 O(n!) 叫做`非多项式量级`，随着规模增大，时间会几句增加，都是==非常低效的算法==。

## O(logn) 的分析


```java
int i=0;
while（i<=n）{
    
    i=i*2
}
```

从以上代码可以看出，设执行次数k 2^k=n，k=logn 
![](https://static001.geekbang.org/resource/image/9b/9a/9b1c88264e7a1a20b5954be9bc4bec9a.jpg)

> i*3 时可以通过log换底公式边变成 k*logn的样式，依然是logn

## 空间复杂度

空间复杂度就是把时间复杂度的代码行替换为变量创建数。和时间复杂度思路类似。

## 各种复杂度

1. 最好复杂度

    最理想情况下的时间复杂度

2. 最差复杂度

    最糟糕情况下的时间复杂度。


3. 平均复杂度

用概率方式计算的加权复杂度
4. 均摊复杂度

一种特殊的平均复杂度，高复杂度和低复杂度是时间上连续的，如果低复杂度可以降低高复杂度带来的效果，就叫做均摊复杂度。
> 比如：前n个操作复杂度都是O(1)，第n+1次操作的复杂度是O(n)，所以把最后一次的复杂度分摊到前n次上，那么均摊下来每次操作的复杂度为O(1)
