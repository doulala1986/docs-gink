
## 数组和链表的区别

1. 数组适合随机访问（而非查找），根据下标查找时 复杂度为O(1)

2. 空间存储结构不一样。地址和存储空间

3. 链表适合插入和删除元素，访问元素效率较低O(n).

4. 数组大小固定，链表不受数据限制。

 
## 提升插入操作的效率

向数组的第k位插入元素:

1. 如果是有序数组，需要将k+1以后的数据后移
2. 如果是非有序数据，可以直接将第k位数据挪到最后

## 提升删除操作的效率

删除数据中第k个元素，可以有以下两种方案：

1. 删除位置后的数据向前移动坐标
2. 标记该位置为删除状态。当数组没有存储空间时，进行真正的删除操作（类似GC的标记-删除）

## ArrayList vs Array
1. ArrayList提供了数组操作API，支持动态扩容
2. ArrayList无法存储基本类型，而使用诸如Long、Integer等类型，将需要承担封包、拆包的效率
3. 多维数组时，Object[][]比 ArrayList<ArrayList>更直观。

> 在底层开发，需要做极致优化时，建议使用数组。

## 为什么使用`0`作为下标

因为寻址时，如果用1作为下标，操作将进行一次额外的减1运算

> a[k]_address = base_address + (k-1)*type_size



---


## 空间换时间

有些算法，空间和时间是可以互换的。当内存空间充足，我们追求速度的时候，可以选择空间复杂度高，时间复杂度低的算法。

## 链表VS ArrayList

ArrayList由于`扩展因子`的特性。可能会占用更多的内存。比如目前arraylist是1G内存，下次扩展就需要扩展为1.5G，还需要把1G内存copy到新的空间。性能和内存都是浪费的。



## `回文`问题

形如：123321，的字符串，叫做回文。如何判断给定字符串是回文？

使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步。快指针到尾部时，慢指针一定是在中点。

在慢指针前进的过程中，同时修改其 next 指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等。

复原链表。


## 链表反转


1. next=current.next //缓存链表的下一个节点


2. current.prev=next//设置prev节点

3. current.next=prev//设置next节点

4.  prev=current//重新设置prev

5. current=next//重新设置current



## 使用`哨兵`简化链表

在创建链表时，定义一个哨兵节点可以简化对于头结点的处理。

哨兵的方法还可以用在很多其他的地方。



## 练习：5个常见的链表操作

1.单链表反转
2.链表中环的检测
3.两个有序链表合并
4.删除链表倒数第n个节点
5.求链表的中间节点


---

## 使用堆栈进行表达式求值


1. 定义两个栈：操作数栈和操作符栈。遍历表达式
2. 当遇到数字时，将数字压入操作数栈
3. 当遇到操作符，将操作符与栈顶操作符比较优先级
4. 如果当前操作符优先级高于栈顶优先级，则压入。否则从操作数栈取2个操作数，从操作符栈顶取操作符，进行计算，把结果压入操作数栈。
5. 最后清空栈
![](https://static001.geekbang.org/resource/image/bc/00/bc77c8d33375750f1700eb7778551600.jpg)


> 使用同样思路，可以利用堆栈检验括号匹配。

## 使用堆栈可以模拟浏览器前进后退

![](https://static001.geekbang.org/resource/image/b5/1b/b5e496e2e28fe08f0388958a0e12861b.jpg)





---

## 循环队列

循环队列为了保证tail head不重合，需要浪费一个空间，队列满的条件是

> (tail + 1 )% n =head

![](https://static001.geekbang.org/resource/image/3d/ec/3d81a44f8c42b3ceee55605f9aeedcec.jpg)


## 队列使用链表和数组实现的区别

1. 使用链表可以支持无界队列，这种队列可能回导致过多的请求排队。不适合响应时间敏感的系统。

2. 使用数组可以实现有界队列，而超过部门会被拒绝。更加适合响应时间敏感的系统。用数组实现的队列实现线程池比较合适。


## 如何实现并发无锁队列

使用CAS实现无锁队列，则在入队前，获取tail位置，入队时比较tail是否发生变化，如果否，则允许入队，反之，本次入队失败。出队则是获取head位置，进行cas

---

## 编写递归编码的关键：

1. 只要遇到递归，把它抽象成一个递归公式，不用想一层层的调用关系，也不要试图用人脑分解递归的步骤。

2. 递归代码要警惕堆栈溢出。

3. 通过Map缓存结果，减少递归中的计算




















