## 排序算法复杂度

![](https://static001.geekbang.org/resource/image/fb/cd/fb8394a588b12ff6695cfd664afb17cd.jpg)

## 冒泡排序

![](https://static001.geekbang.org/resource/image/40/e9/4038f64f47975ab9f519e4f739e464e9.jpg)

> 冒泡排序得优化： 当没有数据交换时，可以提前结束排序操作

最好情况时间复杂度 O（n）
最坏情况时间复杂度 O（n^2）


## 有序度、逆序度、满有序度

有序度：a[i] <= a[j], 如果 i < j。有序度+1

逆序度：与有序度相反

满有序度：n*(n-1)/2

逆序度 = 满有序度-有序度 

逆序度即数据交换的次数


> 冒泡排序的最优有序度是n*(n-1)/2，最差有序度是0，平均有序度是n*(n-1)/4

## 插入排序
前段为有序，从后段中依次选择数字，插入到前段中。

![](https://static001.geekbang.org/resource/image/7b/a6/7b257e179787c633d2bd171a764171a6.jpg)


## 稳定性

即相同元素得相对顺序是否会发生变化。

## 选择排序

![](https://static001.geekbang.org/resource/image/32/1d/32371475a0b08f0db9861d102474181d.jpg)

## 排序对比

![](https://static001.geekbang.org/resource/image/34/50/348604caaf0a1b1d7fee0512822f0e50.jpg)

## 归并排序

![](https://static001.geekbang.org/resource/image/db/2b/db7f892d3355ef74da9cd64aa926dc2b.jpg)


```
递推公式：
merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))

终止条件：
p >= r 不用再继续分解

```

## 分治思想

分治思想事将大问题转化为小问题解决的，归并排序就使用了分治思想。




## 归并排序算法复杂度

一个归并单元包括 2次子单元排序 加上一次归并

> T(n)= 2* T(n/2) +n == 2^k * T(n/2^k) + k * n


无论好、坏、平均时间复杂度都是nlogn，但是由于需要额外的临时空间存储数据，所以空间复杂度是n


空间复杂度为O（n）

## 快速排序

找到分区点pivot，将小于pivot得数字放在左边，大于pivot得数字放在右边。


```
递推公式：
quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)

终止条件：
p >= r

```



伪代码


```
// 快速排序，A 是数组，n 表示数组的大小
quick_sort(A, n) {
  quick_sort_c(A, 0, n-1)
}
// 快速排序递归函数，p,r 为下标
quick_sort_c(A, p, r) {
  if p >= r then return
  
  q = partition(A, p, r) // 获取分区点
  quick_sort_c(A, p, q-1)
  quick_sort_c(A, q+1, r)
}


```

其中分区处理得思路：

> 将分区分为已处理区（前区），未处理区，已处理区的数字都小于pivot，如果发现新的数字，添加到已处理区的末尾。当比较结束后，将pivot放在处理区末尾。

时间平均复杂度是O(nlogn)，在有序环境得到最坏复杂度，复杂度为O(n^2)

## 如何选择分区

快排的分区点的选择会直接影响到快排的效率。如果选择不当，排序时间会退化到O(n^2),可以才去三中比较常见的分区方法：

1. 多数取中值法（一般选3个数）


2. 随机法。


## 使用快排分区分治思路找到第k大元素

思路：当进行一次分区（比较后），会产生povit的位置，其之前的都比他小，之后的都比他大。如果povit的位置p<k，则在后半区再次进行分区，否则则在前半区进行分区。时间复杂度为n+n/2+n/4=2n-1 O(n)


## 10个300M的文件，在可用内存只有1G的情况下，如何合并为一个文件

可以为每个文件分配一个40M的数组，再另外分配一个400M的数组储存归并结果，每个文件每次读取40M，==对十个数组做归并排序直到其中某个数组的数据被处理完==，这时将归并结果写入磁盘，处理完的数组继续读入40M继续参与归并，以此类推，直到所有文件都处理完

---

## 线性排序

在特殊情况下，有一些排序可以达到O(n)的复杂度，比如：桶排序、计数排序、基数排序。这些排序不通过比较算法进行排序，叫做线性排序

## 桶排序
适用场景：比较适用于可以快速的、均匀、按顺序分成较多区的场景。比较适合外部排序，无法一次性读入内存的那种

#### 原理：
桶排序是将n个数均匀划分为k份（k个桶里），对每k份进行快排序，最后将排序好的各份合并

#### 时间复杂度：

k个桶，每个桶内数量近似n/k，每个桶快排的时间复杂度是O（nlogn），所有桶排序得时间复杂度=O(k*n/k logn/k) =O(nlogn/k).当k接近于n时，logn/k会变成很小的常量。所以时间复杂度约为O（n）


最坏情况：

不均匀、桶很少，无法快速分区的时，会回落成O(nlogn).



## 计数排序

#### 适用场景

适合于元素取值范围有限比如学习成绩（0-5），数量多的场景


#### 原理

1. 通过遍历首先计算各个元素的出现个数，生成计数表

2. 通过线性结构，从后向前遍历原数组，通过计数表将元素放置到指定下标的位置，同时变动计数表。

#### 时间复杂度计算

时间复杂度为n





## 基数排序


#### 适用场景

支持相同长度按位计算比较的场景，比如手机号排序、字符串排序等。


#### 原理

分别对每一位进行计数排序，从地位到高位不断的更新顺序


#### 时间复杂度计算

因为计数排序是n，如果有k位，则k次排序，所以时间复杂度也为O（n）

--- 

## 关于排序算法的极致优化

每种排序算法都有它的使用场景，比如

1. 在小规模排序得情况下使用``O(n^2)``的排序也许是更好的选择。
2. 如果内存空间紧张那么就需要选择空间复杂度不高的`快排`，而不是`归并排序`。
3. 使用快排和归并等递归算法时，需要考虑函数调用栈溢出的可能。
    
    - 限制递归深度
    - 模拟函数调用栈

