# 数据读写加速


## 写操作的加速

写操作通常受存储介质的影响，数据库等中间件一般会通过内存映射方式，先将数据更新操作添加到缓存，再由其他工作线程同步到存储。

（特别适合写多、读少的场景，如果要求立刻读，就会导致数据不一致或者频繁写入磁盘）

## 读操作的加速

在用户终端 和 最终存储间，通过多级缓存完成读请求的加速。越靠近用户侧，可控性、一致性越低，但是速度越快。

数据缓存更新策略：在数据修改后，通常通过主动过期缓存的方式引导请求方向最终存储得方向进行回源，回源后再写入缓存。

热点缓存策略：通常通过预加载得方式完成热点数据的缓存。

## 数据加速中对缓存的要求。

对于写操作来说，缓存的容错性很差，必须确保缓存本身的可用性。

对于读缓存来说，有一定的容错性，


## 如何设计高效快照

参考Mysql的一致性查询设计，可以通过tracation_id + 视图的方式设计高效快照。

通过 trx_id 标记标记事务及涉及的行，在事务启动时创建视图，并记录未提交的视图id，当对数据做读取时，需要动态计算得到当前事务可见数据。

*对于Mysql来说，可重复读隔离级别下，查询是一致性读，读取的事务创建时视图；但是更新时的查询都是当前读，读取的是当前数据。*



![](https://static001.geekbang.org/resource/image/88/5e/882114aaf55861832b4270d44507695e.png)


## 零拷贝

零拷贝（zero-copy）是一种目前只有在使用NIO和Epoll传输时才可使用的特性。它使你可以快速高效地将数据从文件系统移动到网络接口，而不需要将其从内核空间复制到用户空间，其在像FTP或者HTTP这样的协议中可以显著地提升性能。但是，并不是所有的操作系统都支持这一特性。特别地，它对于实现了数据加密或者压缩的文件系统是不可用的——只能传输文件的原始内容。反过来说，传输已被加密的文件则不是问题