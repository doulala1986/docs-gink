# MySQL数据库

## 建表优化

### 1. 使用 **自增主键**，减少使用UUID，避免使用业务字段

    由于数据的存储使用的B+树，按照索引顺序进行数据组织。如需要进行数据插入时，会带来移动、分页等连带影响，降低整体效率 使用自增索引，新数据会只添加到树的尾部，不会出现移动元素带来的性能开销。

---

## 事务

### 1. 禁用 **autocommit**，使用自动提交管理业务




### 2. 设计索引时应用`最左前缀原则` + `索引下推`,  以减少索引维护成本


### 3. 设计事务顺序，使热点行的操作尽量靠后执行，减少行级锁对热点行的影响。




### 4. 根据需要，设置死锁检测，减少行级锁可能带来的死锁问题。

```
设置 innodb_deadlock_detect 的值为  on，死锁检测的问题在于会造成很大的cpu消耗。
```


---
## 表空间


### 释放表空间
表空间并不依赖表有效数据行数，建议使用重建表的方式释放表空间

`alter table t engine=innodb`

---

## 语句

### 优先使用count(\*)

count返回的是统计内容不为null的数量。innoDB对count(*)进行了优化，总体效率如下：

count(*) =count(a) > count(主键id) > count(字段)


### 如何获取高性能count(*)

1. 如果希望在一个频繁增删的业务中高效的统计总数，唯一的办法是自己计数。解决一致性视图问题

12 在自己计数的前提下，将计数操作后置，避免了更新行级锁的竞争，效率更高。