# 索引

## B+树

B+树是一种按页划分，按序存放的N叉树，用于存放`索引`。如下图所示：

![](https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png)


其中主键索引的叶子节点的值为`行记录`

非主键索引的叶子节点的值为其表的`主键值`

主键索引建议考虑使用自增方式，减少索引插入、移动、分页的操作。非主键索引无可避免。

联合索引的顺序是按照所以字段依次排序

---

## 覆盖索引

`按照身份证查询姓名` 如果是一个高频操作，如何组织索引？

当有联合索引，联合索引中包括查询结果字段，就不需要进行回表，提升效率。


## 最左前缀原则
索引是按照索引字段的顺序进行存储的，可以按照最左测的前缀进行快速搜索。

![](https://static001.geekbang.org/resource/image/89/70/89f74c631110cfbc83298ef27dcd6370.jpg)

```
例如：

按照最左前缀原则：当设置联合索引(a,b)时，就不需要再定义(a) 索引了。但是(b)的单独索引还是有必要的。
```
1. 首先考虑索引复用问题，尽量通过规划`索引顺序`，少建立索引

2. 当存在单独索引时，应该考虑存储空间。

```
例如：

存在name、age的联合查询，以及name、age的独立查询，应该考虑
1. 建立(name，age)联合索引, 用于支持 联合查询 及 name 的独立查询
2. 建立(age)索引,用于 age 的独立查询
```



## 索引下推

MYSQL5.6以后，支持索引下推，即在索引部分进行条件判断后进行回表。

*5.6之前，会依赖最左前缀法则找到第一个符合条件的记录，然后直接进行回表，在行记录中做条件判断，回表次数较多。*

## 普通索引及唯一索引

搜索效率：`普通索引`与`唯一索引`差距不大

插入效率：由于`唯一索引`需要判断数据重复，所以在数据页不在内存时需要将数据页读入内存，并判断重复后，才可插入，性能成本很高。


**如果可以，有限选择普通索引。如果有插入后，立刻读的情况，应该关闭 change buffer**

## ChangeBuffer类的使用场景

ChangeBuffer 是插入操作的缓存，所有数据变化会优先写入内存后，再批量merge到持久化存储中。适用于非主键索引。

特别适合写多、读少的场景，否则应该关闭change buffer ，因为如果要求立刻读，就会导致数据不一致或者频繁写入磁盘。

##索引的选择


### 索引基数
索引选择是优化器的工作，索引会根据索引基数选择索引。通过以下语句可以查看基数

![](https://static001.geekbang.org/resource/image/16/d4/16dbf8124ad529fec0066950446079d4.png)
```
//Cardinality 即索引基数
show index from [table] 
```

优化器会根据表变更情况触发表分析,生成各个索引的索引基数, 

优化器通常会计算`扫描行数`和`回表情况`,很可能就会出现错误.


### 执行计划查看执行的索引

![](https://static001.geekbang.org/resource/image/e2/89/e2bc5f120858391d4accff05573e1289.png)

在执行计划中，possiable_keys 指定了可用的索引,key指定了实际生效的索引.


### 修正索引

1. 通过 `analyze table`  尝试主动重新计算索引

2. 通过 `force index(xx)` 明确指定索引

3. 通过SQL 语句引导编译器执行索引(非通用方法)







